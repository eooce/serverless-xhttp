<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Rotating Hexagon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            border: 2px solid #444;
            background-color: #111;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
        }
        
        .controls button {
            margin: 5px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .controls button:hover {
            background-color: #45a049;
        }
        
        .controls label {
            display: block;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
        }
        
        .info p {
            margin: 5px 0;
        }
        
        .info span {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <h3>Controls</h3>
        <button onclick="resetBall()">Reset Ball</button>
        <button onclick="togglePause()">Pause/Resume</button>
        <div>
            <label>Gravity: <span id="gravityValue">0.3</span>
                <input type="range" id="gravitySlider" min="0" max="1" step="0.1" value="0.3">
            </label>
        </div>
        <div>
            <label>Friction: <span id="frictionValue">0.98</span>
                <input type="range" id="frictionSlider" min="0.9" max="1" step="0.01" value="0.98">
            </label>
        </div>
        <div>
            <label>Rotation Speed: <span id="rotationSpeedValue">0.005</span>
                <input type="range" id="rotationSpeedSlider" min="0" max="0.02" step="0.001" value="0.005">
            </label>
        </div>
    </div>
    
    <div class="info">
        <h3>Statistics</h3>
        <p>Velocity: <span id="velocity">0.00</span> px/frame</p>
        <p>Rotation: <span id="rotation">0.0</span>Â°</p>
        <p>Position: (<span id="posX">0</span>, <span id="posY">0</span>)</p>
        <p>Status: <span id="status">Running</span></p>
    </div>
    
    <div class="instructions">
        Click anywhere on the canvas to apply force to the ball
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 800;
        canvas.height = 600;
        
        // Hexagon parameters
        const hexagon = {
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            radius: 200,
            rotation: 0,
            rotationSpeed: 0.005
        };
        
        // Ball parameters
        let ball = {
            x: hexagon.centerX,
            y: hexagon.centerY - 50,
            vx: 5,
            vy: 0,
            radius: 15,
            color: '#ff6b6b',
            trail: [],
            glowIntensity: 0
        };
        
        // Physics parameters
        let gravity = 0.3;
        let friction = 0.98;
        let bounceDamping = 0.8;
        let isPaused = false;
        
        // Get hexagon vertices
        function getHexagonVertices() {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + hexagon.rotation;
                const x = hexagon.centerX + hexagon.radius * Math.cos(angle);
                const y = hexagon.centerY + hexagon.radius * Math.sin(angle);
                vertices.push({ x, y });
            }
            return vertices;
        }
        
        // Check if point is inside hexagon
        function isPointInHexagon(px, py) {
            const vertices = getHexagonVertices();
            let inside = false;
            
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const xi = vertices[i].x, yi = vertices[i].y;
                const xj = vertices[j].x, yj = vertices[j].y;
                
                const intersect = ((yi > py) !== (yj > py))
                    && (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        // Get nearest edge and normal
        function getNearestEdgeAndNormal(px, py) {
            const vertices = getHexagonVertices();
            let minDist = Infinity;
            let normal = { x: 0, y: 0 };
            let closestPoint = { x: 0, y: 0 };
            
            for (let i = 0; i < vertices.length; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % vertices.length];
                
                // Calculate closest point on line segment
                const edge = { x: v2.x - v1.x, y: v2.y - v1.y };
                const edgeLength = Math.sqrt(edge.x * edge.x + edge.y * edge.y);
                edge.x /= edgeLength;
                edge.y /= edgeLength;
                
                const toPoint = { x: px - v1.x, y: py - v1.y };
                let t = edge.x * toPoint.x + edge.y * toPoint.y;
                t = Math.max(0, Math.min(edgeLength, t));
                
                const closest = {
                    x: v1.x + edge.x * t,
                    y: v1.y + edge.y * t
                };
                
                const dist = Math.sqrt((px - closest.x) ** 2 + (py - closest.y) ** 2);
                
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = closest;
                    // Calculate normal (perpendicular to edge, pointing inward)
                    normal.x = -edge.y;
                    normal.y = edge.x;
                    
                    // Ensure normal points inward
                    const toCenter = {
                        x: hexagon.centerX - (v1.x + v2.x) / 2,
                        y: hexagon.centerY - (v1.y + v2.y) / 2
                    };
                    if (normal.x * toCenter.x + normal.y * toCenter.y < 0) {
                        normal.x = -normal.x;
                        normal.y = -normal.y;
                    }
                }
            }
            
            return { distance: minDist, normal, closestPoint };
        }
        
        // Handle collision
        function handleCollision() {
            const nextX = ball.x + ball.vx;
            const nextY = ball.y + ball.vy;
            
            if (!isPointInHexagon(nextX, nextY)) {
                const { normal, closestPoint } = getNearestEdgeAndNormal(ball.x, ball.y);
                
                // Calculate relative velocity (considering hexagon rotation)
                const rotVel = {
                    x: -hexagon.rotationSpeed * (closestPoint.y - hexagon.centerY),
                    y: hexagon.rotationSpeed * (closestPoint.x - hexagon.centerX)
                };
                
                const relVx = ball.vx - rotVel.x;
                const relVy = ball.vy - rotVel.y;
                
                // Reflect velocity
                const dot = relVx * normal.x + relVy * normal.y;
                ball.vx = (relVx - 2 * dot * normal.x) * bounceDamping + rotVel.x;
                ball.vy = (relVy - 2 * dot * normal.y) * bounceDamping + rotVel.y;
                
                // Push ball back inside hexagon
                const pushBack = 2;
                ball.x += normal.x * pushBack;
                ball.y += normal.y * pushBack;
                
                // Add glow effect on collision
                ball.glowIntensity = 1;
            }
        }
        
        // Update ball position
        function updateBall() {
            if (isPaused) return;
            
            // Apply gravity
            ball.vy += gravity;
            
            // Apply friction
            ball.vx *= friction;
            ball.vy *= friction;
            
            // Check collision
            handleCollision();
            
            // Update position
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Update trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 30) {
                ball.trail.shift();
            }
            
            // Update hexagon rotation
            hexagon.rotation += hexagon.rotationSpeed;
            
            // Fade glow effect
            ball.glowIntensity *= 0.95;
        }
        
        // Draw hexagon
        function drawHexagon() {
            const vertices = getHexagonVertices();
            
            // Draw hexagon outline
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw vertices
            ctx.fillStyle = '#4CAF50';
            vertices.forEach(v => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Draw ball
        function drawBall() {
            // Draw trail
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ball.trail.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.stroke();
            
            // Draw ball with glow effect
            if (ball.glowIntensity > 0.1) {
                ctx.shadowBlur = 20 * ball.glowIntensity;
                ctx.shadowColor = ball.color;
            }
            
            // Draw ball
            ctx.fillStyle = ball.color;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Draw highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(ball.x - 5, ball.y - 5, ball.radius / 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Update info display
        function updateInfo() {
            const velocity = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);
            document.getElementById('velocity').textContent = velocity.toFixed(2);
            document.getElementById('rotation').textContent = (hexagon.rotation * 180 / Math.PI % 360).toFixed(1);
            document.getElementById('posX').textContent = Math.round(ball.x);
            document.getElementById('posY').textContent = Math.round(ball.y);
            document.getElementById('status').textContent = isPaused ? 'Paused' : 'Running';
        }
        
        // Main animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateBall();
            drawHexagon();
            drawBall();
            updateInfo();
            
            requestAnimationFrame(animate);
        }
        
        // Reset ball position
        function resetBall() {
            ball.x = hexagon.centerX;
            ball.y = hexagon.centerY - 50;
            ball.vx = Math.random() * 10 - 5;
            ball.vy = 0;
            ball.trail = [];
            ball.glowIntensity = 0;
        }
        
        // Toggle pause
        function togglePause() {
            isPaused = !isPaused;
        }
        
        // Update slider values
        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravity;
        });
        
        document.getElementById('frictionSlider').addEventListener('input', (e) => {
            friction = parseFloat(e.target.value);
            document.getElementById('frictionValue').textContent = friction;
        });
        
        document.getElementById('rotationSpeedSlider').addEventListener('input', (e) => {
            hexagon.rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotationSpeedValue').textContent = hexagon.rotationSpeed;
        });
        
        // Mouse click to apply force
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            const dx = clickX - ball.x;
            const dy = clickY - ball.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                ball.vx += (dx / dist) * 10;
                ball.vy += (dy / dist) * 10;
            }
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
